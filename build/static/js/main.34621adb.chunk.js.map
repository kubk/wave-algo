{"version":3,"sources":["component/Maze.tsx","logic/WaveColorGenerator.ts","component/App.tsx","logic/WaveAlgorithm.ts","logic/Maze.ts","logic/MazeGenerator.ts","index.tsx"],"names":["Maze","_Component","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","apply","arguments","inherits","createClass","key","value","maze","backtrace","cell","find","backtraceCell","coordinatesAreTheSame","_this","_this$props","props","onCellClick","waveColorGenerator","react_default","a","createElement","className","toArray","map","row","rowIndex","columnIndex","style","isWaveStep","backgroundColor","generate","onClick","e","onContextMenu","classNames","wall","isWall","start","isStart","finish","isFinish","isBacktrace","wave","Component","WaveColorGenerator","rectangle","waveColorDiff","getWidth","getHeight","step","r","getColor","g","b","concat","initial","Math","floor","App","_React$Component","call","timeoutIds","handleClick","event","coordinate","preventDefault","interruptAnimation","state","isRightClick","setFinish","setStart","setState","forEach","clearTimeout","setTimeout","callback","timeout","push","runWaveAlgo","asyncToGenerator","regenerator_default","mark","_callee","waveAlgorithm","_waveAlgorithm$propag","waves","isFinishFound","wrap","_context","prev","next","clearWaves","propagateWave","animateWavePropagation","generateBacktrace","getFinish","alert","stop","generateNewMaze","mazeGenerator","nativeEvent","which","_this2","Promise","resolve","_loop","i","setWaveStep","length","Maze_Maze","assign","React","WaveAlgorithm","visited","queue","getStart","notVisited","currentCell","queued","shift","toConsumableArray","availableForMove","reduce","nextAvailableCells","getNeighbors","filter","isCellAvailableForMove","withoutVisited","uniqBy","finishCell","fromCell","toCell","isPreviousWave","Error","boolMatrix","startCell","hasCoordinate","newStart","undefined","left","right","newFinish","toString","toInitialState","Number","isInteger","cellValue","MazeGenerator","rows","columns","generateBoolMatrix","findRandomEmptyCell","wallOrEmpty","random","Array","columnFrom","columnTo","randomRow","randomColumn","ReactDOM","render","App_App","document","getElementById"],"mappings":"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","file":"static/js/main.34621adb.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport { Maze as MazeModel, Cell } from '../logic/Maze';\nimport { WaveColorGenerator } from '../logic/WaveColorGenerator';\nimport classNames from 'classnames';\n\ninterface Props {\n  maze: MazeModel;\n  backtrace: Cell[];\n  onCellClick: Function;\n  waveColorGenerator: WaveColorGenerator;\n}\n\nexport class Maze extends Component<Props> {\n  isBacktrace(maze: MazeModel, backtrace: Cell[], cell: Cell): boolean {\n    return !!backtrace.find(backtraceCell => maze.coordinatesAreTheSame(backtraceCell, cell));\n  }\n\n  render() {\n    const { maze, backtrace, onCellClick, waveColorGenerator } = this.props;\n    return (\n      <table className=\"table\">\n        <tbody>\n          {maze.toArray().map((row, rowIndex) => (\n            <tr key={rowIndex} className=\"row\">\n              {row.map((cell, columnIndex) => (\n                <td\n                  style={\n                    maze.isWaveStep(cell)\n                      ? {\n                          backgroundColor: waveColorGenerator.generate(cell as number)\n                        }\n                      : {}\n                  }\n                  key={columnIndex}\n                  onClick={e => onCellClick(e, [rowIndex, columnIndex])}\n                  onContextMenu={e => onCellClick(e, [rowIndex, columnIndex])}\n                  className={classNames({\n                    cell: true,\n                    wall: maze.isWall([rowIndex, columnIndex]),\n                    start: maze.isStart([rowIndex, columnIndex]),\n                    finish: maze.isFinish([rowIndex, columnIndex]),\n                    backtrace: this.isBacktrace(maze, backtrace, [rowIndex, columnIndex]),\n                    wave: maze.isWaveStep(cell)\n                  })}\n                >\n                  {maze.isWaveStep(cell) ? cell : ''}\n                </td>\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    );\n  }\n}\n","interface Rectangle {\n  getWidth(): number;\n  getHeight(): number;\n}\n\nexport class WaveColorGenerator {\n  waveColorDiff: number;\n\n  constructor(rectangle: Rectangle) {\n    this.waveColorDiff = (255 / rectangle.getWidth() / rectangle.getHeight()) * 4;\n  }\n\n  generate(step: number): string {\n    const r = this.getColor(175, step);\n    const g = this.getColor(238, step);\n    const b = this.getColor(255, step);\n\n    return `rgb(${r}, ${g}, ${b})`;\n  }\n\n  getColor(initial: number, step: number): number {\n    return Math.floor(initial - step * this.waveColorDiff);\n  }\n}\n","import React from 'react';\nimport { Maze as MazeView } from './Maze';\nimport { Cell, Maze as MazeModel } from '../logic/Maze';\nimport { Waves } from '../logic/WaveAlgorithm';\nimport { WaveColorGenerator } from '../logic/WaveColorGenerator';\nimport { WaveAlgorithm } from '../logic/WaveAlgorithm';\nimport { MazeGenerator } from '../logic/MazeGenerator';\n\ninterface Props {\n  mazeGenerator: MazeGenerator;\n  waveAlgorithm: WaveAlgorithm;\n}\n\ninterface State {\n  maze: MazeModel;\n  backtrace: Cell[];\n}\n\nexport class App extends React.Component<Props, State> {\n  timeoutIds: NodeJS.Timeout[] = [];\n\n  constructor(props: Props) {\n    super(props);\n\n    this.state = {\n      maze: this.props.mazeGenerator.generate(),\n      backtrace: []\n    };\n  }\n\n  handleClick = (event: Event, coordinate: Cell) => {\n    event.preventDefault();\n    this.interruptAnimation();\n\n    const { maze } = this.state;\n\n    if (this.isRightClick(event)) {\n      maze.setFinish(coordinate);\n    } else {\n      maze.setStart(coordinate);\n    }\n\n    this.setState({ maze, backtrace: [] });\n  };\n\n  isRightClick(event: any): boolean {\n    return event.nativeEvent.which === 3;\n  }\n\n  interruptAnimation = () => {\n    this.timeoutIds.forEach(clearTimeout);\n  };\n\n  /**\n   * Wraps setTimeout for saving timeoutId\n   */\n  setTimeout = (callback: any, timeout: any) => {\n    this.timeoutIds.push(setTimeout(callback, timeout));\n  };\n\n  runWaveAlgo = async () => {\n    this.clearWaves();\n\n    const { waveAlgorithm } = this.props;\n    const { maze } = this.state;\n    const { waves, isFinishFound } = waveAlgorithm.propagateWave(maze);\n\n    await this.animateWavePropagation(maze, waves);\n\n    if (isFinishFound) {\n      this.setTimeout(() => {\n        const backtrace = waveAlgorithm.generateBacktrace(waves, maze.getFinish());\n        this.setState({ backtrace });\n      }, 500);\n    } else {\n      this.setTimeout(() => alert('Cannot find finish'), 500);\n    }\n  };\n\n  animateWavePropagation(maze: MazeModel, waves: Waves): Promise<void> {\n    return new Promise(resolve => {\n      for (let i = 0; i < waves.length - 1; i++) {\n        this.setTimeout(() => {\n          maze.setWaveStep(waves[i], i + 1);\n          this.setState({ maze });\n          if (i === waves.length - 2) {\n            resolve();\n          }\n        }, 200 * i);\n      }\n    });\n  }\n\n  generateNewMaze = () => {\n    this.interruptAnimation();\n    const maze = this.props.mazeGenerator.generate();\n    this.setState({ maze, backtrace: [] });\n  };\n\n  clearWaves = () => {\n    this.interruptAnimation();\n    const { maze } = this.state;\n    maze.clearWaves();\n    this.setState({ maze, backtrace: [] });\n  };\n\n  render() {\n    return (\n      <div className=\"maze\">\n        <MazeView\n          {...this.state}\n          onCellClick={this.handleClick}\n          waveColorGenerator={new WaveColorGenerator(this.state.maze)}\n        />\n        <button className=\"maze-control\" onClick={this.runWaveAlgo}>\n          Run wave algorithm\n        </button>\n        <button className=\"maze-control\" onClick={this.generateNewMaze}>\n          Generate new maze\n        </button>\n        <button className=\"maze-control\" onClick={this.clearWaves}>\n          Clear waves\n        </button>\n      </div>\n    );\n  }\n}\n","import uniqBy from 'lodash.uniqby';\nimport { Maze, Cell } from './Maze';\n\nexport type Waves = Array<Cell[]>;\nexport type WavePropagationResult = { waves: Waves; isFinishFound: boolean };\n\nexport class WaveAlgorithm {\n  propagateWave(maze: Maze): WavePropagationResult {\n    const waves = [];\n    const visited: Cell[] = [];\n    const queue: Cell[][] = [[maze.getStart()]];\n\n    const notVisited = (currentCell: any) => {\n      return !visited.find(cell => maze.coordinatesAreTheSame(cell, currentCell));\n    };\n\n    let isFinishFound = false;\n    while (queue.length) {\n      const queued = queue.shift() as Cell[];\n      visited.push(...queued);\n\n      const availableForMove = queued.reduce((availableForMove: Cell[], currentCell: Cell) => {\n        const nextAvailableCells = this.getNeighbors(currentCell).filter(\n          maze.isCellAvailableForMove\n        );\n        return availableForMove.concat(nextAvailableCells);\n      }, []);\n\n      const uniqCells = uniqBy(availableForMove, (cell: Cell) => `${cell[0]}${cell[1]}`);\n      const withoutVisited = uniqCells.filter(notVisited) as Cell[];\n\n      if (withoutVisited.length) {\n        queue.push(withoutVisited);\n        waves.push(withoutVisited);\n      }\n      if (withoutVisited.find((cell: Cell) => maze.isFinish(cell))) {\n        isFinishFound = true;\n        break;\n      }\n    }\n\n    return { waves, isFinishFound };\n  }\n\n  private getNeighbors(cell: Cell): Cell[] {\n    return [\n      [cell[0] - 1, cell[1]],\n      [cell[0] + 1, cell[1]],\n      [cell[0], cell[1] - 1],\n      [cell[0], cell[1] + 1]\n    ];\n  }\n\n  generateBacktrace(waves: Waves, finishCell: Cell): Cell[] {\n    const backtrace = [];\n    let fromCell = finishCell;\n    for (let i = waves.length - 1; i > 0; i--) {\n      const next = waves[i - 1].find(toCell => this.isPreviousWave(fromCell, toCell));\n      if (!next) {\n        throw new Error('Backtrace is invalid');\n      }\n      backtrace.push(next);\n      fromCell = next;\n    }\n    return backtrace;\n  }\n\n  private isPreviousWave(fromCell: Cell, toCell: Cell): boolean {\n    return (\n      (toCell[0] + 1 === fromCell[0] && toCell[1] === fromCell[1]) ||\n      (toCell[0] === fromCell[0] && toCell[1] + 1 === fromCell[1]) ||\n      (toCell[0] - 1 === fromCell[0] && toCell[1] === fromCell[1]) ||\n      (toCell[0] === fromCell[0] && toCell[1] - 1 === fromCell[1])\n    );\n  }\n}\n","export type Cell = [number, number];\nexport type Matrix = Array<Array<boolean | number>>;\n\nexport class Maze {\n  boolMatrix: Matrix;\n  startCell?: Cell;\n  finishCell?: Cell;\n\n  constructor(boolMatrix: Matrix, startCell?: Cell, finishCell?: Cell) {\n    this.boolMatrix = boolMatrix;\n    if (startCell) {\n      this.setStart(startCell);\n    }\n    if (finishCell) {\n      this.setFinish(finishCell);\n    }\n  }\n\n  setStart(newStart: Cell): void {\n    if (!this.hasCoordinate(newStart)) {\n      throw new Error(`Invalid coordinate`);\n    }\n    if (this.isWall(newStart) || this.isFinish(newStart)) {\n      return;\n    }\n    this.startCell = newStart;\n    this.clearWaves();\n  }\n\n  isStart(coordinate: Cell): boolean {\n    return this.startCell !== undefined && this.coordinatesAreTheSame(this.startCell, coordinate);\n  }\n\n  isFinish(coordinate: Cell): boolean {\n    return this.finishCell !== undefined && this.coordinatesAreTheSame(this.finishCell, coordinate);\n  }\n\n  coordinatesAreTheSame(left: Cell, right: Cell): boolean {\n    return left[0] === right[0] && left[1] === right[1];\n  }\n\n  isWall(cell: Cell): boolean {\n    return this.boolMatrix[cell[0]][cell[1]] === true;\n  }\n\n  setFinish(newFinish: Cell): void {\n    if (!this.hasCoordinate(newFinish)) {\n      throw new Error(`Invalid coordinate: ${newFinish.toString()}`);\n    }\n    if (this.isWall(newFinish) || this.isStart(newFinish)) {\n      return;\n    }\n    this.finishCell = newFinish;\n    this.clearWaves();\n  }\n\n  hasCoordinate(coordinate: Cell): boolean {\n    return (\n      this.boolMatrix[coordinate[0]] !== undefined &&\n      this.boolMatrix[coordinate[0]][coordinate[1]] !== undefined\n    );\n  }\n\n  getStart(): Cell {\n    return this.startCell as Cell;\n  }\n\n  getFinish(): Cell {\n    return this.finishCell as Cell;\n  }\n\n  toArray(): Matrix {\n    return this.boolMatrix;\n  }\n\n  isCellAvailableForMove = (cell: Cell): boolean => {\n    return this.hasCoordinate(cell) && !this.isWall(cell);\n  };\n\n  setWaveStep(wave: Cell[], step: number): void {\n    wave.forEach((cell: Cell) => {\n      this.boolMatrix[cell[0]][cell[1]] = step;\n    });\n  }\n\n  clearWaves(): void {\n    const toInitialState = (cell: number | boolean) => {\n      return cell && !Number.isInteger(cell as number);\n    };\n    this.boolMatrix = this.boolMatrix.map(row => row.map(toInitialState));\n  }\n\n  isWaveStep(cellValue: boolean | number): boolean {\n    return Number.isInteger(cellValue as number);\n  }\n\n  getWidth(): number {\n    return this.boolMatrix[0].length;\n  }\n\n  getHeight(): number {\n    return this.boolMatrix.length;\n  }\n}\n","import { Maze, Cell, Matrix } from './Maze';\n\nexport class MazeGenerator {\n  generate(rows: number = 12, columns: number = 28): Maze {\n    if (rows < 2 || columns < 2) {\n      throw new Error('Invalid maze params');\n    }\n    const maze = new Maze(this.generateBoolMatrix(rows, columns));\n    // Pick the first 3 columns\n    maze.setStart(this.findRandomEmptyCell(maze, 0, 3));\n    // Pick the last 3 columns\n    maze.setFinish(this.findRandomEmptyCell(maze, columns - 4, columns - 1));\n\n    return maze;\n  }\n\n  private generateBoolMatrix(rows: number, columns: number): Matrix {\n    const wallOrEmpty = (): boolean => Math.random() > 0.77;\n\n    return [...Array(rows)].map(() => [...Array(columns)].map(wallOrEmpty));\n  }\n\n  private findRandomEmptyCell(maze: Maze, columnFrom: number, columnTo: number): Cell {\n    const randomRow = Math.floor(Math.random() * maze.getHeight());\n    const randomColumn = Math.floor(Math.random() * (columnTo - columnFrom + 1)) + columnFrom;\n\n    return maze.isWall([randomRow, randomColumn])\n      ? this.findRandomEmptyCell(maze, columnFrom, columnTo)\n      : [randomRow, randomColumn];\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './component/App';\nimport './css/index.scss';\nimport { WaveAlgorithm } from './logic/WaveAlgorithm';\nimport { MazeGenerator } from './logic/MazeGenerator';\n\nconst waveAlgorithm = new WaveAlgorithm();\nconst mazeGenerator = new MazeGenerator();\n\nReactDOM.render(\n  <App waveAlgorithm={waveAlgorithm} mazeGenerator={mazeGenerator} />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}